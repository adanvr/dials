#' Parameter objects related to tree- and rule-based models.
#'
#' These are objects that can be used for modeling, especially in conjunction
#'  with the \pkg{parsnip} package.
#'
#' @details
#' These objects are pre-made parameter sets that are useful when the model is
#'  based on trees or rules.
#'
#' * `mtry()` and `mtry_long()`: The number of predictors that will be randomly
#'   sampled at each split when creating the tree models. The latter uses a
#'   log transformation and is helpful when the data set has a large number of
#'   columns. `mtry()` is used by \pkg{parsnip}'s `parsnip::rand_forest()` function.
#' * `trees()`: The number of trees contained in a random forest or boosted
#'   ensemble. In the latter case, this is equal to the number of boosting
#'   iterations. (see `parsnip::rand_forest()` and `parsnip::boost_tree()`)
#'   functions.
#' * `min_n()`: The minimum number of data points in a node that are required
#'   for the node to be split further. (`parsnip::rand_forest()` and
#'   `parsnip::boost_tree()`)
#' * `sample_size()`: the size of the data set used for modeling within an
#'   iteration of the modeling algorithm, such as stochastic gradient boosting.
#'   (`parsnip::boost_tree()`)
#' * `learn_rate()`: the rate at which the boosting algorithm adapts from
#'   iteration-to-iteration. (`parsnip::boost_tree()`)
#' * `loss_reduction()`:  The reduction in the loss function required to split
#'   further. (`parsnip::boost_tree()`)
#' * `tree_depth()`: The maximum depth of the tree (i.e. number of splits).
#'   (`parsnip::boost_tree()`)
#' * `prune()`: a logical for whether a tree or set of rules should be pruned.
#' * `Cp()`: The cost-complexity parameter in classical CART models.
#'
#' @return Each object is generated by either `new_quant_param()` or
#' `new_qual_param()`.
#'
#' @aliases tree_parameters
#' @export
#' @rdname tree_parameters
mtry <- function(range = c(1L, unknown())) {
  new_quant_param(
    type = "integer",
    range = range,
    inclusive = c(TRUE, TRUE),
    trans = NULL,
    label = c(mtry = "# Randomly Selected Predictors"),
    finalize = get_p
  )
}

#' @export
#' @rdname tree_parameters
#' @importFrom scales log10_trans
mtry_long <- function(range = c(0L, unknown())) {
  new_quant_param(
    type = "integer",
    range = range,
    inclusive = c(TRUE, TRUE),
    trans = log10_trans(),
    label = c(mtry_long = "# Randomly Selected Predictors"),
    finalize = get_log_p
  )
}

#' @rdname tree_parameters
#' @export
trees <- function(range = c(1L, 2000L)) {
  new_quant_param(
    type = "integer",
    range = range,
    inclusive = c(TRUE, TRUE),
    trans = NULL,
    label = c(trees = "# Trees"),
    finalize = NULL
  )
}

#' @rdname tree_parameters
#' @export
min_n <- function(range = c(2L, unknown())) {
  new_quant_param(
    type = "integer",
    range = range,
    inclusive = c(TRUE, TRUE),
    trans = NULL,
    label = c(min_n = "Minimal Node Size"),
    finalize = get_n_frac
  )
}

#' @rdname tree_parameters
#' @export
sample_size <- function(range = c(unknown(), unknown())) {
  new_quant_param(
    type = "integer",
    range = range,
    inclusive = c(TRUE, TRUE),
    trans = NULL,
    label = c(sample_size = "# Observations Sampled"),
    finalize = get_n_frac_range
  )
}

#' @rdname tree_parameters
#' @export
learn_rate <- function(range = c(unknown(), unknown())) {
  new_quant_param(
    type = "double",
    range = range,
    inclusive = c(TRUE, TRUE),
    trans = NULL,
    label = c(learn_rate = "Learning Rate"),
    finalize = NULL
  )
}


#' @rdname tree_parameters
#' @export
loss_reduction <- function(range = c(unknown(), unknown())) {
  new_quant_param(
    type = "double",
    range = range,
    inclusive = c(TRUE, TRUE),
    trans = NULL,
    label = c(loss_reduction = "Minimum Loss Reduction"),
    finalize = NULL
  )
}

#' @rdname tree_parameters
#' @export
tree_depth <- function(range = c(2L, 15L)) {
  new_quant_param(
    type = "integer",
    range = range,
    inclusive = c(TRUE, TRUE),
    trans = NULL,
    label = c(tree_depth = "Tree Depth"),
    finalize = NULL
  )
}

#' @export
#' @rdname tree_parameters
prune <- function(values = c(TRUE, FALSE)) {
  new_qual_param(
    type = "logical",
    values = values,
    label = c(prune = "Pruning"),
    finalize = NULL
  )
}

#' @export
#' @rdname tree_parameters
Cp <- function(range = c(-10, -1)) {
  new_quant_param(
    type = "double",
    range = range,
    inclusive = c(TRUE, TRUE),
    trans = log10_trans(),
    label = c(Cp = "Cost-Complexity Parameter"),
    finalize = NULL
  )
}

###################################################################

#' Parameter objects related to parametric models.
#'
#' These are objects that can be used for modeling, especially in conjunction
#'  with the \pkg{parsnip} package.
#'
#' @details
#' These objects are pre-made parameter sets that are useful when the model is
#'  based on some type of slope/intercept model.
#'
#' * `penalty()`: The total amount of regularization used. This is used by
#'   `parsnip::linear_reg()` and `parsnip::logistic_reg()` with glmnet models.
#' * `mixture()`: the proportion of L1 regularization in the model.
#'   (`parsnip::linear_reg()` and `parsnip::logistic_reg()`)
#' * `dropout()`: the parameter dropout rate. (`parsnip:::mlp()`)
#' * `epochs()`: the number of iterations of training. (`parsnip:::mlp()`)
#' * `activation()`: the type of activation function between network layers.
#'    (`parsnip:::mlp()`)
#' * `hidden_units()`: the number of hidden units in a network layer.
#'    (`parsnip:::mlp()`)
#' * `batch_size()`: the mini-batch size for neural networks.
#' * `rbf_sigma()`: the sigma parameters of a radial basis function.
#' * `cost()`: a cost value for SVM models.
#' * `scale_factor()`: the polynomial and hyperbolic tangent kernel scaling factor.
#' * `margin()`: the SVM margin parameter (e.g. epsilon in the insensitive-loss
#'    function for regression).
#' * `degree()`: the polynomial degree.
#' * `prod_degree()`: the number of terms to combine into interactions. A value of
#'    1 implies an additive model. Useful for MARS models.
#' * `num_terms()`: a nonspecific parameter for the number of terms in a model.
#'   This can be used with models that include feature selection, such as MARS.
#' * `num_comp()`: the number of components in a model (e.g. PCA or PLS components).
#' * `deg_free()`: a parameter for the degrees of freedom.
#' * `prune_method()`: a parameter for pruming methods for MARS.
#'
#' @return Each object is generated by either `new_quant_param()` or
#' `new_qual_param`.
#' @aliases para_parameters
#' @rdname para_parameters
#' @export
#' @export
dropout <- function(range = c(0, 1)) {
  new_quant_param(
    type = "double",
    range = range,
    inclusive = c(TRUE, FALSE),
    trans = NULL,
    label = c(dropout = "Dropout Rate"),
    finalize = NULL
  )
}

#' @rdname para_parameters
#' @export
epochs <- function(range = c(1L, 1000L)) {
  new_quant_param(
    type = "integer",
    range = c(1L, 1000L),
    inclusive = c(TRUE, TRUE),
    trans = NULL,
    label = c(epochs = "# Epochs"),
    finalize = NULL
  )
}

#' @rdname para_parameters
#' @export
activation <- function(values = c("linear", "softmax", "relu", "elu")) {
  new_qual_param(
    type = "character",
    values = values,
    label = c(activation = "Activation Function"),
    finalize = NULL
  )
}

#' @rdname para_parameters
#' @export
mixture <- function(range = c(0, 1)) {
  new_quant_param(
    type = "double",
    range = range,
    inclusive = c(TRUE, TRUE),
    trans = NULL,
    label = c(mixture = "% lasso Penalty"),
    finalize = NULL
  )
}

#' @rdname para_parameters
#' @export
penalty <- function(range = c(-10, 0)) {
  new_quant_param(
    type = "double",
    range = range,
    inclusive = c(TRUE, TRUE),
    trans = log10_trans(),
    label = c(penalty = "Amount of Regularization"),
    finalize = NULL
  )
}

#' @export
#' @rdname para_parameters
rbf_sigma <- function(range = c(-10, 0)) {
  new_quant_param(
    type = "double",
    range = range,
    inclusive = c(TRUE, TRUE),
    trans = log10_trans(),
    label = c(rbf_sigma = "Radial Basis Function sigma"),
    finalize = get_rbf_range
  )
}

#' @export
#' @rdname para_parameters
prod_degree <- function(range = c(1L, 2L)) {
  new_quant_param(
    type = "integer",
    range = range,
    inclusive = c(TRUE, TRUE),
    trans = NULL,
    label = c(prod_degree = "Degree of Interaction"),
    finalize = NULL
  )
}

#' @export
#' @rdname para_parameters
num_terms <- function(range = c(1L, unknown())) {
  new_quant_param(
    type = "integer",
    range = range,
    inclusive = c(TRUE, TRUE),
    trans = NULL,
    label = c(num_terms = "# Model Terms"),
    finalize = get_p
  )
}

#' @export
#' @rdname para_parameters
num_comp <- function(range = c(1L, unknown())) {
  new_quant_param(
    type = "integer",
    range = range,
    inclusive = c(TRUE, TRUE),
    trans = NULL,
    label = c(num_comp = "# Components"),
    finalize = get_p
  )
}

#' @export
#' @rdname para_parameters
cost <- function(range = c(-10, -1)) {
  new_quant_param(
    type = "double",
    range = range,
    inclusive = c(TRUE, TRUE),
    trans = log2_trans(),
    label = c(cost = "Cost"),
    finalize = NULL
  )
}

#' @export
#' @rdname para_parameters
scale_factor <- function(range = c(-10, -1)) {
  new_quant_param(
    type = "double",
    range = range,
    inclusive = c(TRUE, TRUE),
    trans = log2_trans(),
    label = c(cost = "Scale Factor"),
    finalize = NULL
  )
}

#' @export
#' @rdname para_parameters
margin <- function(range = c(0, .2)) {
  new_quant_param(
    type = "double",
    range = range,
    inclusive = c(TRUE, TRUE),
    trans = NULL,
    label = c(cost = "Insensitivity Margin"),
    finalize = NULL
  )
}

#' @export
#' @rdname para_parameters
degree <- function(range = c(1, 3)) {
  new_quant_param(
    type = "double",
    range = range,
    inclusive = c(TRUE, TRUE),
    trans = NULL,
    label = c(degree = "Polynomial Degree"),
    finalize = NULL
  )
}

#' @export
#' @rdname para_parameters
deg_free <- function(range = c(1, 5)) {
  new_quant_param(
    type = "double",
    range = range,
    inclusive = c(TRUE, TRUE),
    trans = NULL,
    label = c(deg_free = "Degrees of Freedom"),
    finalize = NULL
  )
}

#' @export
#' @rdname para_parameters
hidden_units <- function(range = c(1L, 10)) {
  new_quant_param(
    type = "integer",
    range = range,
    inclusive = c(TRUE, TRUE),
    trans = NULL,
    label = c(hidden_units = "# Hidden Units"),
    finalize = NULL
  )
}

#' @export
#' @rdname para_parameters
#' @importFrom scales log2_trans
batch_size <- function(range = c(unknown(), unknown())) {
  new_quant_param(
    type = "double",
    range = range,
    inclusive = c(TRUE, TRUE),
    trans = log2_trans(),
    label = c(cost = "Batch Size"),
    finalize = get_batch_sizes
  )
}

#' @export
#' @rdname para_parameters
prune_method <-
  new_qual_param(
    type     = c("character"),
    values   = c("backward", "none", "exhaustive", "forward", "seqrep", "cv"),
    default  = "backward",
    label    = c(prune_method = "Pruning Method"),
    finalize = NULL
  )


###################################################################

#' Parameter objects related to miscellaneous models.
#'
#' These are objects that can be used for modeling, especially in conjunction
#'  with the \pkg{parsnip} package.
#'
#' @details
#' These objects are pre-made parameter sets that are useful in a variety of
#' models.
#'
#' * `weight_func()`: The type of kernel function that weights the distances
#'    between samples (e.g. in a K-nearest neighbors model).
#' * `surv_dist()`: the statistical distribution of the data in a survival
#'   analysis model (e.g. `parsnip::surv_reg()`) .
#' * `Laplace()`: the Laplace correction used to smooth low-frequency counts.
#' * `neighbors()`: a parameter for the number of neighbors used in a prototype
#'   model.
#' * `dist_power()`: The order parameter used in calculating a Minkowski distance.
#' * `threshold()`: A general thresholding parameter for values between `[0, 1]`.
#' @return Each object is generated by either `new_quant_param()` or
#' `new_qual_param`.
#' @aliases misc_parameters
#' @rdname misc_parameters
#' @export
weight_func <- function(values = c("rectangular", "triangular", "epanechnikov",
                                   "biweight", "triweight", "cos", "inv",
                                   "gaussian", "rank", "optimal")) {
  new_qual_param(
    type = "character",
    values = values,
    label = c(weight_func = "Distance Weighting Function"),
    finalize = NULL
  )
}

# in reference to survival::survreg
#' @rdname misc_parameters
#' @export
surv_dist <- function(values = c("weibull", "exponential", "gaussian",
                                 "logistic", "lognormal", "loglogistic")) {
  new_qual_param(
    type = "character",
    values = values,
    label = c(surv_dist = "Distribution"),
    finalize = NULL
  )
}

#' @export
#' @rdname misc_parameters
Laplace <- function(range = c(0, 3)) {
  new_quant_param(
    type = "double",
    range = range,
    inclusive = c(TRUE, TRUE),
    trans = NULL,
    default = 0,
    label = c(Laplace = "Laplace Correction"),
    finalize = NULL
  )
}


#' @export
#' @rdname misc_parameters
neighbors <- function(range = c(1L, unknown())) {
  new_quant_param(
    type = "integer",
    range = range,
    inclusive = c(TRUE, TRUE),
    trans = NULL,
    label = c(neighbors = "# Nearest Neighbors"),
    finalize = get_n_frac
  )
}

#' @export
#' @rdname misc_parameters
dist_power <- function(range = c(1, 2)) {
  new_quant_param(
    type = "double",
    range = range,
    inclusive = c(TRUE, TRUE),
    trans = NULL,
    label = c(neighbors = "Minkowski Distance Order")
  )
}


#' @export
#' @rdname misc_parameters
threshold <- function(range = c(0, 1)) {
  new_quant_param(
    type = "double",
    range = range,
    inclusive = c(TRUE, TRUE),
    trans = NULL,
    default = 0.5,
    label = c(threshold = "Threshold"),
    finalize = NULL
  )
}


###################################################################

#' Parameter objects related to text analysis.
#'
#' These are objects that can be used for modeling, especially in conjunction
#'  with the \pkg{textrecipes} package.
#'
#' @details
#' These objects are pre-made parameter sets that are useful in a variety of
#' models.
#'
#' * `min_times()`, `max_times()`: frequency of word occurances for removal.
#'   See `?step_tokenfilter`.
#' * `max_tokens()`: the number of tokens that will be retained. See
#'   `?step_tokenfilter`.
#' * `weight()`: A parameter for "double normalization" when creating token
#'   counts. See `?step_tf`.
#' * `weight_scheme()`: the method for  term frequency calculations. Possible
#'    values are: "binary", "raw count", "term frequency", "log normalization",
#'    or "double normalization". See `?step_tf`.
#' * `token()`: the type of token with possible values: "characters",
#'   "character_shingle", "lines", "ngrams", "paragraphs", "ptb", "regex",
#'   "sentences", "skip_ngrams", "tweets", "words", "word_stems". See
#'   `?step_tokenize`
#' @return Each object is generated by either `new_quant_param()` or
#' `new_qual_param()`.
#' @aliases text_parameters
#' @rdname text_parameters
#' @export
#'

#' @export
#' @rdname text_parameters
weight <- function(range = c(-10, 0)) {
  new_quant_param(
    type = "double",
    range = range,
    inclusive = c(TRUE, TRUE),
    trans = log10_trans(),
    label = c(weight = "Weight"),
    finalize = NULL
  )
}

#' @export
#' @rdname text_parameters
weight_scheme <- function(values = c("raw count", "binary",
                                     "term frequency", "log normalization",
                                     "double normalization")) {
  new_qual_param(
    type = "character",
    values = values,
    label = c(weight_scheme = "Term Frequency Weight Method"),
    finalize = NULL
  )
}

#' @export
#' @rdname text_parameters
token <- function(values = c("words", "characters", "character_shingle",
                             "lines", "ngrams", "paragraphs", "ptb", "regex",
                             "sentences", "skip_ngrams", "tweets",
                             "word_stems")) {
  new_qual_param(
    type = "character",
    values = values,
    label = c(weight_scheme = "Token Unit"),
    finalize = NULL
  )
}

#' @export
#' @rdname text_parameters
max_times <- function(range = c(1L, as.integer(10^5))) {
  new_quant_param(
    type = "integer",
    range = range,
    inclusive = c(TRUE, TRUE),
    trans = NULL,
    label = c(max_times = "Maximum Token Frequency"),
    finalize = NULL
  )
}


#' @export
#' @rdname text_parameters
min_times <- function(range = c(0L, 1000L)) {
  new_quant_param(
    type = "integer",
    range = range,
    inclusive = c(TRUE, TRUE),
    trans = NULL,
    label = c(min_times = "Minimum Token Frequency"),
    finalize = NULL
  )
}


#' @export
#' @rdname text_parameters
max_tokens <- function(range = c(0L, as.integer(10^5))) {
  new_quant_param(
    type = "integer",
    range = range,
    inclusive = c(TRUE, TRUE),
    trans = NULL,
    label = c(min_times = "# Retained Tokens"),
    finalize = NULL
  )
}




